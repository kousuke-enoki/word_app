// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package settingUc

import (
	"context"

	"word_app/backend/src/domain"
	settingUc "word_app/backend/src/usecase/setting"

	mock "github.com/stretchr/testify/mock"
)

// NewMockGetAuthConfig creates a new instance of MockGetAuthConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetAuthConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetAuthConfig {
	mock := &MockGetAuthConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetAuthConfig is an autogenerated mock type for the GetAuthConfig type
type MockGetAuthConfig struct {
	mock.Mock
}

type MockGetAuthConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetAuthConfig) EXPECT() *MockGetAuthConfig_Expecter {
	return &MockGetAuthConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetAuthConfig
func (_mock *MockGetAuthConfig) Execute(ctx context.Context) (*settingUc.AuthConfigDTO, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *settingUc.AuthConfigDTO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*settingUc.AuthConfigDTO, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *settingUc.AuthConfigDTO); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settingUc.AuthConfigDTO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetAuthConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetAuthConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGetAuthConfig_Expecter) Execute(ctx interface{}) *MockGetAuthConfig_Execute_Call {
	return &MockGetAuthConfig_Execute_Call{Call: _e.mock.On("Execute", ctx)}
}

func (_c *MockGetAuthConfig_Execute_Call) Run(run func(ctx context.Context)) *MockGetAuthConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockGetAuthConfig_Execute_Call) Return(authConfigDTO *settingUc.AuthConfigDTO, err error) *MockGetAuthConfig_Execute_Call {
	_c.Call.Return(authConfigDTO, err)
	return _c
}

func (_c *MockGetAuthConfig_Execute_Call) RunAndReturn(run func(ctx context.Context) (*settingUc.AuthConfigDTO, error)) *MockGetAuthConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGetRootConfig creates a new instance of MockGetRootConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetRootConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetRootConfig {
	mock := &MockGetRootConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetRootConfig is an autogenerated mock type for the GetRootConfig type
type MockGetRootConfig struct {
	mock.Mock
}

type MockGetRootConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetRootConfig) EXPECT() *MockGetRootConfig_Expecter {
	return &MockGetRootConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetRootConfig
func (_mock *MockGetRootConfig) Execute(ctx context.Context, in settingUc.InputGetRootConfig) (*settingUc.OutputGetRootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *settingUc.OutputGetRootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetRootConfig) (*settingUc.OutputGetRootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetRootConfig) *settingUc.OutputGetRootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settingUc.OutputGetRootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputGetRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetRootConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetRootConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputGetRootConfig
func (_e *MockGetRootConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockGetRootConfig_Execute_Call {
	return &MockGetRootConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockGetRootConfig_Execute_Call) Run(run func(ctx context.Context, in settingUc.InputGetRootConfig)) *MockGetRootConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputGetRootConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputGetRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockGetRootConfig_Execute_Call) Return(outputGetRootConfig *settingUc.OutputGetRootConfig, err error) *MockGetRootConfig_Execute_Call {
	_c.Call.Return(outputGetRootConfig, err)
	return _c
}

func (_c *MockGetRootConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputGetRootConfig) (*settingUc.OutputGetRootConfig, error)) *MockGetRootConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGetUserConfig creates a new instance of MockGetUserConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetUserConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetUserConfig {
	mock := &MockGetUserConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetUserConfig is an autogenerated mock type for the GetUserConfig type
type MockGetUserConfig struct {
	mock.Mock
}

type MockGetUserConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetUserConfig) EXPECT() *MockGetUserConfig_Expecter {
	return &MockGetUserConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetUserConfig
func (_mock *MockGetUserConfig) Execute(ctx context.Context, in settingUc.InputGetUserConfig) (*settingUc.OutputGetUserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *settingUc.OutputGetUserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetUserConfig) (*settingUc.OutputGetUserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetUserConfig) *settingUc.OutputGetUserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settingUc.OutputGetUserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputGetUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetUserConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetUserConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputGetUserConfig
func (_e *MockGetUserConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockGetUserConfig_Execute_Call {
	return &MockGetUserConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockGetUserConfig_Execute_Call) Run(run func(ctx context.Context, in settingUc.InputGetUserConfig)) *MockGetUserConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputGetUserConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputGetUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockGetUserConfig_Execute_Call) Return(outputGetUserConfig *settingUc.OutputGetUserConfig, err error) *MockGetUserConfig_Execute_Call {
	_c.Call.Return(outputGetUserConfig, err)
	return _c
}

func (_c *MockGetUserConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputGetUserConfig) (*settingUc.OutputGetUserConfig, error)) *MockGetUserConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSettingFacade creates a new instance of MockSettingFacade. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSettingFacade(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSettingFacade {
	mock := &MockSettingFacade{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSettingFacade is an autogenerated mock type for the SettingFacade type
type MockSettingFacade struct {
	mock.Mock
}

type MockSettingFacade_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSettingFacade) EXPECT() *MockSettingFacade_Expecter {
	return &MockSettingFacade_Expecter{mock: &_m.Mock}
}

// GetAuth provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) GetAuth(ctx context.Context) (*settingUc.AuthConfigDTO, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAuth")
	}

	var r0 *settingUc.AuthConfigDTO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*settingUc.AuthConfigDTO, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *settingUc.AuthConfigDTO); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settingUc.AuthConfigDTO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_GetAuth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuth'
type MockSettingFacade_GetAuth_Call struct {
	*mock.Call
}

// GetAuth is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockSettingFacade_Expecter) GetAuth(ctx interface{}) *MockSettingFacade_GetAuth_Call {
	return &MockSettingFacade_GetAuth_Call{Call: _e.mock.On("GetAuth", ctx)}
}

func (_c *MockSettingFacade_GetAuth_Call) Run(run func(ctx context.Context)) *MockSettingFacade_GetAuth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockSettingFacade_GetAuth_Call) Return(authConfigDTO *settingUc.AuthConfigDTO, err error) *MockSettingFacade_GetAuth_Call {
	_c.Call.Return(authConfigDTO, err)
	return _c
}

func (_c *MockSettingFacade_GetAuth_Call) RunAndReturn(run func(ctx context.Context) (*settingUc.AuthConfigDTO, error)) *MockSettingFacade_GetAuth_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) GetRoot(ctx context.Context, in settingUc.InputGetRootConfig) (*settingUc.OutputGetRootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 *settingUc.OutputGetRootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetRootConfig) (*settingUc.OutputGetRootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetRootConfig) *settingUc.OutputGetRootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settingUc.OutputGetRootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputGetRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type MockSettingFacade_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputGetRootConfig
func (_e *MockSettingFacade_Expecter) GetRoot(ctx interface{}, in interface{}) *MockSettingFacade_GetRoot_Call {
	return &MockSettingFacade_GetRoot_Call{Call: _e.mock.On("GetRoot", ctx, in)}
}

func (_c *MockSettingFacade_GetRoot_Call) Run(run func(ctx context.Context, in settingUc.InputGetRootConfig)) *MockSettingFacade_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputGetRootConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputGetRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_GetRoot_Call) Return(outputGetRootConfig *settingUc.OutputGetRootConfig, err error) *MockSettingFacade_GetRoot_Call {
	_c.Call.Return(outputGetRootConfig, err)
	return _c
}

func (_c *MockSettingFacade_GetRoot_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputGetRootConfig) (*settingUc.OutputGetRootConfig, error)) *MockSettingFacade_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) GetUser(ctx context.Context, in settingUc.InputGetUserConfig) (*settingUc.OutputGetUserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *settingUc.OutputGetUserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetUserConfig) (*settingUc.OutputGetUserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputGetUserConfig) *settingUc.OutputGetUserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settingUc.OutputGetUserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputGetUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type MockSettingFacade_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputGetUserConfig
func (_e *MockSettingFacade_Expecter) GetUser(ctx interface{}, in interface{}) *MockSettingFacade_GetUser_Call {
	return &MockSettingFacade_GetUser_Call{Call: _e.mock.On("GetUser", ctx, in)}
}

func (_c *MockSettingFacade_GetUser_Call) Run(run func(ctx context.Context, in settingUc.InputGetUserConfig)) *MockSettingFacade_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputGetUserConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputGetUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_GetUser_Call) Return(outputGetUserConfig *settingUc.OutputGetUserConfig, err error) *MockSettingFacade_GetUser_Call {
	_c.Call.Return(outputGetUserConfig, err)
	return _c
}

func (_c *MockSettingFacade_GetUser_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputGetUserConfig) (*settingUc.OutputGetUserConfig, error)) *MockSettingFacade_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRoot provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) UpdateRoot(ctx context.Context, in settingUc.InputUpdateRootConfig) (*domain.RootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRoot")
	}

	var r0 *domain.RootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateRootConfig) (*domain.RootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateRootConfig) *domain.RootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.RootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputUpdateRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_UpdateRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRoot'
type MockSettingFacade_UpdateRoot_Call struct {
	*mock.Call
}

// UpdateRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputUpdateRootConfig
func (_e *MockSettingFacade_Expecter) UpdateRoot(ctx interface{}, in interface{}) *MockSettingFacade_UpdateRoot_Call {
	return &MockSettingFacade_UpdateRoot_Call{Call: _e.mock.On("UpdateRoot", ctx, in)}
}

func (_c *MockSettingFacade_UpdateRoot_Call) Run(run func(ctx context.Context, in settingUc.InputUpdateRootConfig)) *MockSettingFacade_UpdateRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputUpdateRootConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputUpdateRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_UpdateRoot_Call) Return(rootConfig *domain.RootConfig, err error) *MockSettingFacade_UpdateRoot_Call {
	_c.Call.Return(rootConfig, err)
	return _c
}

func (_c *MockSettingFacade_UpdateRoot_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputUpdateRootConfig) (*domain.RootConfig, error)) *MockSettingFacade_UpdateRoot_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) UpdateUser(ctx context.Context, in settingUc.InputUpdateUserConfig) (*domain.UserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *domain.UserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateUserConfig) (*domain.UserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateUserConfig) *domain.UserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputUpdateUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockSettingFacade_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputUpdateUserConfig
func (_e *MockSettingFacade_Expecter) UpdateUser(ctx interface{}, in interface{}) *MockSettingFacade_UpdateUser_Call {
	return &MockSettingFacade_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, in)}
}

func (_c *MockSettingFacade_UpdateUser_Call) Run(run func(ctx context.Context, in settingUc.InputUpdateUserConfig)) *MockSettingFacade_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputUpdateUserConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputUpdateUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_UpdateUser_Call) Return(userConfig *domain.UserConfig, err error) *MockSettingFacade_UpdateUser_Call {
	_c.Call.Return(userConfig, err)
	return _c
}

func (_c *MockSettingFacade_UpdateUser_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputUpdateUserConfig) (*domain.UserConfig, error)) *MockSettingFacade_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateRootConfig creates a new instance of MockUpdateRootConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateRootConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateRootConfig {
	mock := &MockUpdateRootConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateRootConfig is an autogenerated mock type for the UpdateRootConfig type
type MockUpdateRootConfig struct {
	mock.Mock
}

type MockUpdateRootConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateRootConfig) EXPECT() *MockUpdateRootConfig_Expecter {
	return &MockUpdateRootConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUpdateRootConfig
func (_mock *MockUpdateRootConfig) Execute(ctx context.Context, in settingUc.InputUpdateRootConfig) (*domain.RootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *domain.RootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateRootConfig) (*domain.RootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateRootConfig) *domain.RootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.RootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputUpdateRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateRootConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUpdateRootConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputUpdateRootConfig
func (_e *MockUpdateRootConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockUpdateRootConfig_Execute_Call {
	return &MockUpdateRootConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockUpdateRootConfig_Execute_Call) Run(run func(ctx context.Context, in settingUc.InputUpdateRootConfig)) *MockUpdateRootConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputUpdateRootConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputUpdateRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUpdateRootConfig_Execute_Call) Return(rootConfig *domain.RootConfig, err error) *MockUpdateRootConfig_Execute_Call {
	_c.Call.Return(rootConfig, err)
	return _c
}

func (_c *MockUpdateRootConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputUpdateRootConfig) (*domain.RootConfig, error)) *MockUpdateRootConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateUserConfig creates a new instance of MockUpdateUserConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateUserConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateUserConfig {
	mock := &MockUpdateUserConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateUserConfig is an autogenerated mock type for the UpdateUserConfig type
type MockUpdateUserConfig struct {
	mock.Mock
}

type MockUpdateUserConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateUserConfig) EXPECT() *MockUpdateUserConfig_Expecter {
	return &MockUpdateUserConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUpdateUserConfig
func (_mock *MockUpdateUserConfig) Execute(ctx context.Context, in settingUc.InputUpdateUserConfig) (*domain.UserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *domain.UserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateUserConfig) (*domain.UserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settingUc.InputUpdateUserConfig) *domain.UserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settingUc.InputUpdateUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateUserConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUpdateUserConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settingUc.InputUpdateUserConfig
func (_e *MockUpdateUserConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockUpdateUserConfig_Execute_Call {
	return &MockUpdateUserConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockUpdateUserConfig_Execute_Call) Run(run func(ctx context.Context, in settingUc.InputUpdateUserConfig)) *MockUpdateUserConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settingUc.InputUpdateUserConfig
		if args[1] != nil {
			arg1 = args[1].(settingUc.InputUpdateUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUpdateUserConfig_Execute_Call) Return(userConfig *domain.UserConfig, err error) *MockUpdateUserConfig_Execute_Call {
	_c.Call.Return(userConfig, err)
	return _c
}

func (_c *MockUpdateUserConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settingUc.InputUpdateUserConfig) (*domain.UserConfig, error)) *MockUpdateUserConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}
