// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package settinguc

import (
	"context"

	"word_app/backend/src/domain"
	settinguc "word_app/backend/src/usecase/setting"

	mock "github.com/stretchr/testify/mock"
)

// NewMockGetRootConfig creates a new instance of MockGetRootConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetRootConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetRootConfig {
	mock := &MockGetRootConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetRootConfig is an autogenerated mock type for the GetRootConfig type
type MockGetRootConfig struct {
	mock.Mock
}

type MockGetRootConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetRootConfig) EXPECT() *MockGetRootConfig_Expecter {
	return &MockGetRootConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetRootConfig
func (_mock *MockGetRootConfig) Execute(ctx context.Context, in settinguc.InputGetRootConfig) (*settinguc.OutputGetRootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *settinguc.OutputGetRootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetRootConfig) (*settinguc.OutputGetRootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetRootConfig) *settinguc.OutputGetRootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settinguc.OutputGetRootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputGetRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetRootConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetRootConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputGetRootConfig
func (_e *MockGetRootConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockGetRootConfig_Execute_Call {
	return &MockGetRootConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockGetRootConfig_Execute_Call) Run(run func(ctx context.Context, in settinguc.InputGetRootConfig)) *MockGetRootConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputGetRootConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputGetRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockGetRootConfig_Execute_Call) Return(outputGetRootConfig *settinguc.OutputGetRootConfig, err error) *MockGetRootConfig_Execute_Call {
	_c.Call.Return(outputGetRootConfig, err)
	return _c
}

func (_c *MockGetRootConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputGetRootConfig) (*settinguc.OutputGetRootConfig, error)) *MockGetRootConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGetRuntimeConfig creates a new instance of MockGetRuntimeConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetRuntimeConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetRuntimeConfig {
	mock := &MockGetRuntimeConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetRuntimeConfig is an autogenerated mock type for the GetRuntimeConfig type
type MockGetRuntimeConfig struct {
	mock.Mock
}

type MockGetRuntimeConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetRuntimeConfig) EXPECT() *MockGetRuntimeConfig_Expecter {
	return &MockGetRuntimeConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetRuntimeConfig
func (_mock *MockGetRuntimeConfig) Execute(ctx context.Context) (*settinguc.RuntimeConfigDTO, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *settinguc.RuntimeConfigDTO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*settinguc.RuntimeConfigDTO, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *settinguc.RuntimeConfigDTO); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settinguc.RuntimeConfigDTO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetRuntimeConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetRuntimeConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGetRuntimeConfig_Expecter) Execute(ctx interface{}) *MockGetRuntimeConfig_Execute_Call {
	return &MockGetRuntimeConfig_Execute_Call{Call: _e.mock.On("Execute", ctx)}
}

func (_c *MockGetRuntimeConfig_Execute_Call) Run(run func(ctx context.Context)) *MockGetRuntimeConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockGetRuntimeConfig_Execute_Call) Return(runtimeConfigDTO *settinguc.RuntimeConfigDTO, err error) *MockGetRuntimeConfig_Execute_Call {
	_c.Call.Return(runtimeConfigDTO, err)
	return _c
}

func (_c *MockGetRuntimeConfig_Execute_Call) RunAndReturn(run func(ctx context.Context) (*settinguc.RuntimeConfigDTO, error)) *MockGetRuntimeConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGetUserConfig creates a new instance of MockGetUserConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetUserConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetUserConfig {
	mock := &MockGetUserConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetUserConfig is an autogenerated mock type for the GetUserConfig type
type MockGetUserConfig struct {
	mock.Mock
}

type MockGetUserConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetUserConfig) EXPECT() *MockGetUserConfig_Expecter {
	return &MockGetUserConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetUserConfig
func (_mock *MockGetUserConfig) Execute(ctx context.Context, in settinguc.InputGetUserConfig) (*settinguc.OutputGetUserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *settinguc.OutputGetUserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetUserConfig) (*settinguc.OutputGetUserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetUserConfig) *settinguc.OutputGetUserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settinguc.OutputGetUserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputGetUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetUserConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetUserConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputGetUserConfig
func (_e *MockGetUserConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockGetUserConfig_Execute_Call {
	return &MockGetUserConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockGetUserConfig_Execute_Call) Run(run func(ctx context.Context, in settinguc.InputGetUserConfig)) *MockGetUserConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputGetUserConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputGetUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockGetUserConfig_Execute_Call) Return(outputGetUserConfig *settinguc.OutputGetUserConfig, err error) *MockGetUserConfig_Execute_Call {
	_c.Call.Return(outputGetUserConfig, err)
	return _c
}

func (_c *MockGetUserConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputGetUserConfig) (*settinguc.OutputGetUserConfig, error)) *MockGetUserConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSettingFacade creates a new instance of MockSettingFacade. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSettingFacade(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSettingFacade {
	mock := &MockSettingFacade{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSettingFacade is an autogenerated mock type for the SettingFacade type
type MockSettingFacade struct {
	mock.Mock
}

type MockSettingFacade_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSettingFacade) EXPECT() *MockSettingFacade_Expecter {
	return &MockSettingFacade_Expecter{mock: &_m.Mock}
}

// GetRoot provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) GetRoot(ctx context.Context, in settinguc.InputGetRootConfig) (*settinguc.OutputGetRootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 *settinguc.OutputGetRootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetRootConfig) (*settinguc.OutputGetRootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetRootConfig) *settinguc.OutputGetRootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settinguc.OutputGetRootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputGetRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type MockSettingFacade_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputGetRootConfig
func (_e *MockSettingFacade_Expecter) GetRoot(ctx interface{}, in interface{}) *MockSettingFacade_GetRoot_Call {
	return &MockSettingFacade_GetRoot_Call{Call: _e.mock.On("GetRoot", ctx, in)}
}

func (_c *MockSettingFacade_GetRoot_Call) Run(run func(ctx context.Context, in settinguc.InputGetRootConfig)) *MockSettingFacade_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputGetRootConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputGetRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_GetRoot_Call) Return(outputGetRootConfig *settinguc.OutputGetRootConfig, err error) *MockSettingFacade_GetRoot_Call {
	_c.Call.Return(outputGetRootConfig, err)
	return _c
}

func (_c *MockSettingFacade_GetRoot_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputGetRootConfig) (*settinguc.OutputGetRootConfig, error)) *MockSettingFacade_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRuntimeConfig provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) GetRuntimeConfig(ctx context.Context) (*settinguc.RuntimeConfigDTO, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRuntimeConfig")
	}

	var r0 *settinguc.RuntimeConfigDTO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*settinguc.RuntimeConfigDTO, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *settinguc.RuntimeConfigDTO); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settinguc.RuntimeConfigDTO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_GetRuntimeConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRuntimeConfig'
type MockSettingFacade_GetRuntimeConfig_Call struct {
	*mock.Call
}

// GetRuntimeConfig is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockSettingFacade_Expecter) GetRuntimeConfig(ctx interface{}) *MockSettingFacade_GetRuntimeConfig_Call {
	return &MockSettingFacade_GetRuntimeConfig_Call{Call: _e.mock.On("GetRuntimeConfig", ctx)}
}

func (_c *MockSettingFacade_GetRuntimeConfig_Call) Run(run func(ctx context.Context)) *MockSettingFacade_GetRuntimeConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockSettingFacade_GetRuntimeConfig_Call) Return(runtimeConfigDTO *settinguc.RuntimeConfigDTO, err error) *MockSettingFacade_GetRuntimeConfig_Call {
	_c.Call.Return(runtimeConfigDTO, err)
	return _c
}

func (_c *MockSettingFacade_GetRuntimeConfig_Call) RunAndReturn(run func(ctx context.Context) (*settinguc.RuntimeConfigDTO, error)) *MockSettingFacade_GetRuntimeConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) GetUser(ctx context.Context, in settinguc.InputGetUserConfig) (*settinguc.OutputGetUserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *settinguc.OutputGetUserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetUserConfig) (*settinguc.OutputGetUserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputGetUserConfig) *settinguc.OutputGetUserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*settinguc.OutputGetUserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputGetUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type MockSettingFacade_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputGetUserConfig
func (_e *MockSettingFacade_Expecter) GetUser(ctx interface{}, in interface{}) *MockSettingFacade_GetUser_Call {
	return &MockSettingFacade_GetUser_Call{Call: _e.mock.On("GetUser", ctx, in)}
}

func (_c *MockSettingFacade_GetUser_Call) Run(run func(ctx context.Context, in settinguc.InputGetUserConfig)) *MockSettingFacade_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputGetUserConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputGetUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_GetUser_Call) Return(outputGetUserConfig *settinguc.OutputGetUserConfig, err error) *MockSettingFacade_GetUser_Call {
	_c.Call.Return(outputGetUserConfig, err)
	return _c
}

func (_c *MockSettingFacade_GetUser_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputGetUserConfig) (*settinguc.OutputGetUserConfig, error)) *MockSettingFacade_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRoot provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) UpdateRoot(ctx context.Context, in settinguc.InputUpdateRootConfig) (*domain.RootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRoot")
	}

	var r0 *domain.RootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateRootConfig) (*domain.RootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateRootConfig) *domain.RootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.RootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputUpdateRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_UpdateRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRoot'
type MockSettingFacade_UpdateRoot_Call struct {
	*mock.Call
}

// UpdateRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputUpdateRootConfig
func (_e *MockSettingFacade_Expecter) UpdateRoot(ctx interface{}, in interface{}) *MockSettingFacade_UpdateRoot_Call {
	return &MockSettingFacade_UpdateRoot_Call{Call: _e.mock.On("UpdateRoot", ctx, in)}
}

func (_c *MockSettingFacade_UpdateRoot_Call) Run(run func(ctx context.Context, in settinguc.InputUpdateRootConfig)) *MockSettingFacade_UpdateRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputUpdateRootConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputUpdateRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_UpdateRoot_Call) Return(rootConfig *domain.RootConfig, err error) *MockSettingFacade_UpdateRoot_Call {
	_c.Call.Return(rootConfig, err)
	return _c
}

func (_c *MockSettingFacade_UpdateRoot_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputUpdateRootConfig) (*domain.RootConfig, error)) *MockSettingFacade_UpdateRoot_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function for the type MockSettingFacade
func (_mock *MockSettingFacade) UpdateUser(ctx context.Context, in settinguc.InputUpdateUserConfig) (*domain.UserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *domain.UserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateUserConfig) (*domain.UserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateUserConfig) *domain.UserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputUpdateUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSettingFacade_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockSettingFacade_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputUpdateUserConfig
func (_e *MockSettingFacade_Expecter) UpdateUser(ctx interface{}, in interface{}) *MockSettingFacade_UpdateUser_Call {
	return &MockSettingFacade_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, in)}
}

func (_c *MockSettingFacade_UpdateUser_Call) Run(run func(ctx context.Context, in settinguc.InputUpdateUserConfig)) *MockSettingFacade_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputUpdateUserConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputUpdateUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSettingFacade_UpdateUser_Call) Return(userConfig *domain.UserConfig, err error) *MockSettingFacade_UpdateUser_Call {
	_c.Call.Return(userConfig, err)
	return _c
}

func (_c *MockSettingFacade_UpdateUser_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputUpdateUserConfig) (*domain.UserConfig, error)) *MockSettingFacade_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateRootConfig creates a new instance of MockUpdateRootConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateRootConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateRootConfig {
	mock := &MockUpdateRootConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateRootConfig is an autogenerated mock type for the UpdateRootConfig type
type MockUpdateRootConfig struct {
	mock.Mock
}

type MockUpdateRootConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateRootConfig) EXPECT() *MockUpdateRootConfig_Expecter {
	return &MockUpdateRootConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUpdateRootConfig
func (_mock *MockUpdateRootConfig) Execute(ctx context.Context, in settinguc.InputUpdateRootConfig) (*domain.RootConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *domain.RootConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateRootConfig) (*domain.RootConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateRootConfig) *domain.RootConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.RootConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputUpdateRootConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateRootConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUpdateRootConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputUpdateRootConfig
func (_e *MockUpdateRootConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockUpdateRootConfig_Execute_Call {
	return &MockUpdateRootConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockUpdateRootConfig_Execute_Call) Run(run func(ctx context.Context, in settinguc.InputUpdateRootConfig)) *MockUpdateRootConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputUpdateRootConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputUpdateRootConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUpdateRootConfig_Execute_Call) Return(rootConfig *domain.RootConfig, err error) *MockUpdateRootConfig_Execute_Call {
	_c.Call.Return(rootConfig, err)
	return _c
}

func (_c *MockUpdateRootConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputUpdateRootConfig) (*domain.RootConfig, error)) *MockUpdateRootConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateUserConfig creates a new instance of MockUpdateUserConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateUserConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateUserConfig {
	mock := &MockUpdateUserConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateUserConfig is an autogenerated mock type for the UpdateUserConfig type
type MockUpdateUserConfig struct {
	mock.Mock
}

type MockUpdateUserConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateUserConfig) EXPECT() *MockUpdateUserConfig_Expecter {
	return &MockUpdateUserConfig_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUpdateUserConfig
func (_mock *MockUpdateUserConfig) Execute(ctx context.Context, in settinguc.InputUpdateUserConfig) (*domain.UserConfig, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *domain.UserConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateUserConfig) (*domain.UserConfig, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, settinguc.InputUpdateUserConfig) *domain.UserConfig); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, settinguc.InputUpdateUserConfig) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateUserConfig_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUpdateUserConfig_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - in settinguc.InputUpdateUserConfig
func (_e *MockUpdateUserConfig_Expecter) Execute(ctx interface{}, in interface{}) *MockUpdateUserConfig_Execute_Call {
	return &MockUpdateUserConfig_Execute_Call{Call: _e.mock.On("Execute", ctx, in)}
}

func (_c *MockUpdateUserConfig_Execute_Call) Run(run func(ctx context.Context, in settinguc.InputUpdateUserConfig)) *MockUpdateUserConfig_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 settinguc.InputUpdateUserConfig
		if args[1] != nil {
			arg1 = args[1].(settinguc.InputUpdateUserConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUpdateUserConfig_Execute_Call) Return(userConfig *domain.UserConfig, err error) *MockUpdateUserConfig_Execute_Call {
	_c.Call.Return(userConfig, err)
	return _c
}

func (_c *MockUpdateUserConfig_Execute_Call) RunAndReturn(run func(ctx context.Context, in settinguc.InputUpdateUserConfig) (*domain.UserConfig, error)) *MockUpdateUserConfig_Execute_Call {
	_c.Call.Return(run)
	return _c
}
